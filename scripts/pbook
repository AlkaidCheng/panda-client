#!/bin/bash

"exec" "python" "-u" "-Wignore" "$0" "$@"


import os
import sys
import code
import atexit
import signal
import datetime
import tempfile
import commands
import optparse
import readline
import rlcompleter

from pandatools import PdbUtils
from pandatools import Client
from pandatools import BookConfig
from pandatools import PLogger
from pandatools import PsubUtils
from pandatools import PandaToolsPkgInfo
from pandatools import BookConfig

# readline support
readline.parse_and_bind('tab: complete')
readline.parse_and_bind('set show-all-if-ambiguous On')

# history support
pconfDir = os.path.expanduser(os.environ['PANDA_CONFIG_ROOT'])
if not os.path.exists(pconfDir):
    os.makedirs(pconfDir)
historyFile = '%s/.history' % pconfDir
if os.path.exists(historyFile):
    readline.read_history_file(historyFile)
readline.set_history_length(1024)

# set dummy CMTSITE
if not os.environ.has_key('CMTSITE'):
    os.environ['CMTSITE'] = ''

# make tmp dir
tmpDir = tempfile.mkdtemp()

# exit action
def _onExit(dirName,hFile):
    readline.write_history_file(hFile)
    commands.getoutput('rm -rf %s' % dirName)
atexit.register(_onExit,tmpDir,historyFile)

# look for PandaTools package
for path in sys.path:
    if path == '':
        path = '.'
    if os.path.exists(path) and 'pandatools' in os.listdir(path):
        # make symlink for module name
        os.symlink('%s/pandatools' % path,'%s/taskbuffer' % tmpDir)
        break
sys.path = [tmpDir]+sys.path



# core class for book keeping
class PBookCore:

    # constructor
    def __init__(self,enforceEnter=False,verbose=False):
        # verbose
        self.verbose = verbose
        # initialize database
        PdbUtils.initialzieDB(self.verbose)
        # check proxy
        self.gridPassPhrase,self.vomsFQAN = PsubUtils.checkGridProxy('',enforceEnter,self.verbose)


    # synchronize database
    def sync(self):
        # get logger
        tmpLog = PLogger.getPandaLogger()
        tmpLog.info("Synchronizing local database. It may take a couple of minutes")
        # check proxy
        self.gridPassPhrase,self.vomsFQAN = PsubUtils.checkGridProxy(self.gridPassPhrase,False,self.verbose)
        # get JobIDs in local database
        localJobIDs = PdbUtils.getListOfJobIDs()
        # get recent JobIDs from panda server
        syncTime = datetime.datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S')
        # set sync time for the first attempt
        bookConf = BookConfig.getConfig()
        if bookConf.last_synctime == '':
            bookConf.last_synctime = datetime.datetime.utcnow()-datetime.timedelta(days=180)
            bookConf.last_synctime = bookConf.last_synctime.strftime('%Y-%m-%d %H:%M:%S')
        status,remoteJobIDs = Client.getJobIDsInTimeRange(bookConf.last_synctime,verbose=self.verbose)
        if status != 0:
            tmpLog.error("Failed to get JobIDs from panda server")
            return
        tmpLog.info("Gotton %s jobs to be updated" % len(remoteJobIDs))
        # insert if missing
        for remoteJobID in remoteJobIDs:
            # check local status
            if remoteJobID in localJobIDs:
                # get job info from local database
                job = PdbUtils.readJobDB(remoteJobID,self.verbose)
                # skip if frozen
                if job.dbStatus == 'frozen':
                    continue
            tmpLog.info("Updating JobID=%s ..." % remoteJobID)
            # get PandaIDs
            status,pandaIDstatus = Client.getPandIDsWithJobID(remoteJobID,verbose=self.verbose)
            if status != 0:
                tmpLog.error("Failed to get PandaIDs for %s" % remoteJobID) 
                return
            pandaIDs = pandaIDstatus.keys()
            pandaIDs.sort()
            # get full JobSpec
            tmpIDs = [pandaIDs[0],pandaIDs[-1]]
            status,pandaJobs = Client.getFullJobStatus(tmpIDs,verbose=self.verbose)
            if status != 0:
                tmpLog.error("Failed to get PandaIDs for %s" % remoteJobID) 
                return
            # convert to local job spec
            localJob = PdbUtils.convertPtoD(pandaJobs,pandaIDstatus)
            # update database 
            if not remoteJobID in localJobIDs:
                # insert to DB
                try:
                    PdbUtils.insertJobDB(localJob,self.verbose)
                except:
                    tmpLog.error("Failed to insert JobID=%s to local DB" % remoteJobID)
                    return
            else:
                # update
                try:
                    PdbUtils.updateJobDB(localJob,self.verbose)
                except:
                    tmpLog.error("Failed to update local DB for JobID=%s" % remoteJobID)
                    return
        # update sync time
        bookConf = BookConfig.getConfig()
        bookConf.last_synctime = syncTime
        BookConfig.updateConfig(bookConf)
        tmpLog.info("Synchronization Completed")
        

    # get local job info
    def getJobInfo(self,JobID):
        # get logger
        tmpLog = PLogger.getPandaLogger()
        # get job info from local database
        job = PdbUtils.readJobDB(JobID,self.verbose)
        # not found
        if job == None:
            tmpLog.warning("JobID=%s not found in local DB. Synchronization may be needed" % JobID)
            return None
        # return
        return job


    # get local job list
    def getLocalJobList(self):
        # get JobIDs in local database
        localJobIDs = PdbUtils.getListOfJobIDs()
        # get jobs
        localJobs = []
        for JobID in localJobIDs:
            job = PdbUtils.readJobDB(JobID,self.verbose)
            # append
            localJobs.append(job)
        # return
        return localJobs
    
        
    # get status
    def status(self,JobID):
        # get logger
        tmpLog = PLogger.getPandaLogger()
        # check proxy
        self.gridPassPhrase,self.vomsFQAN = PsubUtils.checkGridProxy(self.gridPassPhrase,False,self.verbose)
        # get job info from local database
        job = self.getJobInfo(JobID)
        if job == None:
            tmpLog.warning("JobID=%s not found in local DB. Synchronization may be needed" % JobID)            
            return None
        # update if needed
        if job.dbStatus != 'frozen':
            tmpLog.info("Getting status for JobID=%s ..." % remoteJobID)            
            # get status from Panda server
            status,pandaIDstatus = Client.getPandIDsWithJobID(JobID,
                                                              nJobs=len(job.PandaID.split(',')),
                                                              verbose=self.verbose)
            if status != 0:
                tmpLog.error("Failed to get status for JobID=%s" % JobID)
                return None
            # convert to local job spec
            job = PdbUtils.convertPtoD([],pandaIDstatus,job)
            # update DB
            try:
                PdbUtils.updateJobDB(job,self.verbose)
            except:
                tmpLog.error("Failed to update local DB for JobID=%s" % JobID)
                return None
        # return
        return job


    # kill
    def kill(self,JobID):
        # get logger
        tmpLog = PLogger.getPandaLogger()
        # check proxy
        self.gridPassPhrase,self.vomsFQAN = PsubUtils.checkGridProxy(self.gridPassPhrase,False,self.verbose)
        # get job info from local database
        job = self.getJobInfo(JobID)
        if job == None:
            tmpLog.warning("JobID=%s not found in local DB. Synchronization may be needed" % JobID)            
            return None
	# skip frozen job
        if job.dbStatus == 'frozen':
            tmpLog.info('Skip because all sub-jobs already finished/failed')
            return
        # get PandaID list
        killJobs = job.PandaID.split(',')
        # kill
        tmpLog.info('Sending kill command ...')
        status,output = Client.killJobs(killJobs,self.verbose)
        if status != 0:
            tmpLog.error(output)
            tmpLog.error("Failed to kill JobID=%s" % JobID)
            return
        # update database
        job.commandToPilot = 'tobekilled'
        # update DB
        try:
            PdbUtils.updateJobDB(job,self.verbose)
        except:
            tmpLog.error("Failed to update local DB for JobID=%s" % JobID)
            return
        # done
        tmpLog.info('Done. JobID=%s will be killed in 30min' % JobID)
        return



# main for interactive session
def intmain(pbookCore):

    # show status
    def show(JobID=None):
        # show all local info
        if JobID == None:
            jobList = pbookCore.getLocalJobList()
            # print
            for job in jobList:
                print "======================================"
                print job
        else:
            job = pbookCore.getJobInfo(JobID)
            # print
            print "======================================"
            print job


    # kill
    def kill(JobID):
        pbookCore.kill(JobID)


    # go to interactive prompt
    code.interact(banner="\nStart pBook %s" % PandaToolsPkgInfo.release_version,
                  local=locals())



# main for GUI session
def guimain(pbookCore):
    import gtk
    from pandatools import BookGUI
    pbookGuiMain = BookGUI.PBookGuiMain(pbookCore)
    # get logger
    tmpLog = PLogger.getPandaLogger()
    tmpLog.info("Start pBook %s" % PandaToolsPkgInfo.release_version)
    # GTK main
    gtk.main()
    

# kill whole process
def catch_sig(sig, frame):
    # kill
    commands.getoutput('kill -9 -- -%s' % os.getpgrp())


# overall main
if __name__ == "__main__":

    # parse option
    parser = optparse.OptionParser()
    parser.add_option("-v",action="store_true",dest="verbose",default=False,
                      help="verbose")
    parser.add_option("--gui",action="store_true",dest="gui",default=False,
                      help="use GUI")
    parser.add_option("--noPass",action="store_true",dest="noPass",default=False,
                      help="disable to enter pass phrase for GUI")
    parser.add_option('--version',action='store_const',const=True,dest='version',default=False,
                      help='Displays version')
    parser.add_option('--devSrv',action='store_const',const=True,dest='devSrv',default=False,
                      help="Please don't use this option. Only for developers to use the dev panda server")
    
    options, args = parser.parse_args()

    # display version
    if options.version:
        print "Version: %s" % PandaToolsPkgInfo.release_version
        sys.exit(0)

    # use dev server
    if options.devSrv:
        Client.useDevServer()

    # fork for Ctl-c
    fork_child_pid = os.fork()
    if fork_child_pid == -1:
        print "ERROR : Failed to fork"
        sys.exit(1)
    if fork_child_pid == 0:
        # main
        if options.gui:
            # instantiate core with pass phrase
            if options.noPass:
                pbookCore = PBookCore(False,options.verbose)
            else:
                pbookCore = PBookCore(True,options.verbose)                
            # GUI
            guimain(pbookCore)
        else:
            # instantiate core
            pbookCore = PBookCore(False,options.verbose)
            # CUI
            intmain(pbookCore)
    else:
        # set handler
        signal.signal(signal.SIGINT, catch_sig)
        signal.signal(signal.SIGHUP, catch_sig)
        signal.signal(signal.SIGTERM,catch_sig)
        os.wait()
    
